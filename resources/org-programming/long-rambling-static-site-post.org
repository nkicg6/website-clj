#+HTML: <div id="edn">
#+HTML: {:title "Journey to a static site with Clojure" :date "2018-08-07" :tags ["clojure" "static-site"]}
#+HTML: </div>
#+OPTIONS: \n:1 toc:nil num:0 todo:nil ^:{}
#+OPTIONS: toc:t author:nil title:nil date:nil num:nil ^:{} \n:1 todo:nil
#+PROPERTY: header-args :eval never-export
#+DATE: 2018-08-07 Tue

* /Journey to a static site with Clojure/  
* Note!
:PROPERTIES:
:CUSTOM_ID: note
:END:
This is a long rambling journey of me stumbling through learning clojure via building a static site. 
I wouldn't recommend reading it, but I left it here as it may be helpful to someone. I wrote a distilled version [[http://nickgeorge.net/programming/building-my-static-clojure-website/][here]] that I would recommend instead. This one is likely a lot different from my actual site, as I wrote it as I was building my real site, so things are out of order and things I changed may not have been re-explained or updated.
* Part 1: Introduction and header/footer styles with hiccup and org-mode intro
:PROPERTIES:
:CUSTOM_ID: part1
:END:

/2018-08-07/
** Static sites
:PROPERTIES:
:CUSTOM_ID: static-sites
:END:

 These are static collections of HTML, CSS, and JavaScript files that make up simple (but not necessarily so), fast websites. The main difference between static sites and dynamic websites is that static sites do not fetch information from a database upon requests. They simply contain all the HTML, CSS, JS, etc. files that make up the website.
** Why?
:PROPERTIES:
:CUSTOM_ID: why-static-site-and-clojure
:END:

 They are simple and very useful. I don't need anything more complicated for my personal website, and static sites are low maintenance and easy to customize and extend.
*** Why Clojure?
  I am currently learning Clojure, mostly because I wanted to learn functional programming principles and Rich Hickey gives [[https://github.com/tallesl/Rich-Hickey-fanclub][amazing talks]], but also because it is an functional programming language hosted on both the web with ClojureScript (javascript) and the JVM (regular Clojure). ClojureScript seems like it is better javascript,(and it is just trans-piler to javascript), that means that I can use one language to leverage all of javascript and non-web programming or backend web tasks with one well-designed language -- Clojure!
*** Why Stasis?
 My original static website was written with python and the Flask framework and made into a static site with [[https://pythonhosted.org/Frozen-Flask/][Frozen-flask]] and [[https://pythonhosted.org/Flask-FlatPages/][Flask-FlatPages]] for hosting on github pages. I am learning Clojure and websites are a great learning experience, so I going to port it to Clojure using the static site generator [[https://github.com/cryogen-project/cryogen][Cryogen]], a clojure/clojurescript static website generator, but I found the templates hard to understand and customization difficult (for a beginner at least). In the spirit of Clojure (and Tim Ewald's excellent talk [[https://www.youtube.com/watch?v=ShEez0JkOFw][Programming with hand tools]]), I choose to use the [[https://github.com/magnars/stasis][Stasis]], the clojure library for developing (frameworkless) static web sites. I will write about that in this post as I go. 

** Org-mode to html workflow
:PROPERTIES:
:CUSTOM_ID: org-html-workflow
:END:

 [[file:img/org-mode-unicorn-logo.png]]
   I write in Emacs with [[https://orgmode.org/][Org-mode]] markup and plan to publish with Org-publish, so periodically I will be adding notes for how this all works with my org-mode publishing scheme. These will be under the sub heading =org-workflow= 

** Building the website
:PROPERTIES:
:CUSTOM_ID: building-styles-etc
:END:

 /Disclaimer/ 
 I am still very new to Clojure, so my custom code will likely be very beginner-ish and rough, but hopefully it will improve as I go!
  I used Christian Johansen's post on Building static sites in Clojure with Stasis https://cjohansen.no/building-static-sites-in-clojure-with-stasis/ to get started. Everything I do from here on out will be changes and customizations to make the site behave like I want it to. 
*** Style
    After following most of the Christian Johansen's awesome tutorial, the first thing I wanted to do was add [[https://getbootstrap.com/docs/3.3/getting-started/][Twitter Bootstrap]] CSS. I know there is a [[https://github.com/weavejester/hiccup-bootstrap][Hiccup wrapper]] for bootstrap, but since I write in Emacs Org-mode and export to HTML directly, I don't think it is necessary for me. Hiccup looks like simplified HTML, so I changed the name of the function from =layout-page= to =layout-base-header= and added the CDN links from the Bootstrap home page. The function now looks like this:

 #+BEGIN_SRC clojure 
   (defn layout-base-header [page]
     (html5
      [:head
       [:meta {:charset "utf-8"}]
       [:meta {:name "viewport"
               :content "width=device-width, initial-scale=1.0"}]
       [:link {:rel "stylesheet" :href "https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" :integrity "sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" :crossorigin "anonymous"}]
       [:script {:src "https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" :integrity "sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" :crossorigin "anonymous"}]]
      [:body
       [:div.logo "website-clj"]
       [:div.body page]]))

 #+END_SRC

 This seems to work great for my =.md= rendered page, but the base page didn't inherit this styling. Looking through the functions I copied from the tutorial, I am betting it is due to the =get-pages= function. When it declares the =:public= map, it doesn't wrap the =stasis/slurp-directory= call in another function. I assume this just renders them raw. So I will modify =markdown-pages= function for HTML pages to see if this takes care of it. 

 #+BEGIN_SRC clojure 
   (defn markdown-pages [pages]
     (zipmap (map #(str/replace % #"\.md$" "") (keys pages))
             (map #(layout-base-header (md/to-html %)) (vals pages))))

   (defn html-pages [pages]
     (zipmap (map #(str/replace % #"\.html" "") (keys pages))
             (map #(layout-base-header (vals pages)))))

 #+END_SRC

 and then I will change =get-pages= to add this function. 

 #+BEGIN_SRC clojure 
 (defn get-pages []
   (stasis/merge-page-sources
    {:public (html-pages (stasis/slurp-directory "resources/public" #".*\.(html|css|js)$"))
     :partials (partial-pages (stasis/slurp-directory "resources/partials" #".*\.html$"))
     :markdown (markdown-pages (stasis/slurp-directory "resources/md" #".*\.md$"))}))

 #+END_SRC
 But when I refreshed my webpage, I got this horrible error:

 #+BEGIN_EXAMPLE
 1. Unhandled java.lang.IllegalArgumentException
    Don't know how to create ISeq from: clojure.core$map$fn__4781
 ...
 #+END_EXAMPLE

 and on and on. Looks like I have to figure out what these functions are actually doing. 

 First, I'll run one that I know works to see what the output looks like:

 #+BEGIN_SRC clojure 
 (markdown-pages (stasis/slurp-directory "resources/md" #".*\.md$"))
 #+END_SRC

 #+BEGIN_EXAMPLE
 [ "/my-first-md" "<!DOCTYPE html>\n<html><head><meta charset=\"utf-8\"><meta content=\"width=device-width, initial-scale=1.0\" name=\"viewport\"><link crossorigin=\"anonymous\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\" integrity=\"sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u\" rel=\"stylesheet\"><script crossorigin=\"anonymous\" integrity=\"sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa\" src=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js\"></script></head><body><div class=\"logo\">website-clj</div><div class=\"body\"><h1>first md post</h1><p>Short for now</p></div></body></html>" ]

 #+END_EXAMPLE

 Cool. but running the following fails:

 #+BEGIN_SRC clojure 
 (html-pages (stasis/slurp-directory "resources/public" #".*\.html$"))
 #+END_SRC

 #+BEGIN_EXAMPLE
 1. Unhandled java.lang.IllegalArgumentException
    Don't know how to create ISeq from: clojure.core$map$fn__4781
 ...
 #+END_EXAMPLE

 That tells me we are returning a function. And now I see we obviously are with the bottom =map= function! =#()= is an anonymous function, so I need to add the argument =%=! 

 #+BEGIN_SRC clojure 
 (defn html-pages [pages]
   (zipmap (map #(str/replace % #"\.html$" "") (keys pages))
           (map #(layout-base-header %) (vals pages))))
 ;; test
 (html-pages (stasis/slurp-directory "resources/public" #".*\.html$"))
 #+END_SRC

 #+BEGIN_EXAMPLE
 [ "/index" "<!DOCTYPE html>\n<html><head><meta charset=\"utf-8\"><meta content=\"width=device-width, initial-scale=1.0\" name=\"viewport\"><link crossorigin=\"anonymous\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\" integrity=\"sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u\" rel=\"stylesheet\"><script crossorigin=\"anonymous\" integrity=\"sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa\" src=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js\"></script></head><body><div class=\"logo\">website-clj</div><div class=\"body\"><!DOCTYPE html>\n<html>\n  <head>\n    <title>My blog</title>\n  </head>\n  <body>\n    <h1>My blog</h1>\n    <p>\n      Welcome to it.\n    </p>\n  </body>\n</html>\n</div></body></html>" ]

 #+END_EXAMPLE

 Excellent! Now I will start the app up again and see what happens. 

 weird! The landing page can't find it. 
 [[file:img/not-found-index.png]]


 But when I navigate to =/index=, it is right there and working. 

 [[file:img/working-index.png]]

 hmm, I will have to see how the home page will be rendered. When I return to Christian's blog, and re-read the explanation of =get-pages=, I see the only thing I changed was replacing the =.html= with a blank string. When i make the following change to the =html-pages= file, it works fine!

 #+BEGIN_SRC clojure 
 (defn html-pages [pages]
   (zipmap (map #(str/replace % #"\.html$" ".html") (keys pages))
           (map #(layout-base-header %) (vals pages))))


 #+END_SRC

 Cool! so I will make a new folder called "home", and rename the folder "public" to "posts" so that it makes sense for me. After fixing the directory structure, my resources file looks like this:

 #+BEGIN_EXAMPLE
 resources/
 ├── home
 │   └── index.html
 ├── md
 │   └── my-first-md.md
 ├── partials
 │   └── about.html
 └── posts
     └── test-post.html
 #+END_EXAMPLE

 I then added a =home-page= function and modified =get-pages= to properly render. The relevant code (all of it) looks like this now:

 #+BEGIN_SRC clojure 

 (ns website-clj.web
   (:require [clojure.java.io :as io]
             [clojure.string :as str]
             [hiccup.page :refer [html5]]
             [me.raynes.cegdown :as md]
             [stasis.core :as stasis]))




 (defn layout-base-header [page]
   (html5
    [:head
     [:meta {:charset "utf-8"}]
     [:meta {:name "viewport"
             :content "width=device-width, initial-scale=1.0"}]
     [:link {:rel "stylesheet" :href "https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" :integrity "sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" :crossorigin "anonymous"}]
     [:script {:src "https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" :integrity "sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" :crossorigin "anonymous"}]]
    [:body
     [:div.logo "website-clj"]
     [:div.body page]]))

 (def pegdown-options ;; https://github.com/sirthias/pegdown
   [:autolinks :fenced-code-blocks :strikethrough])


 (defn markdown-pages [pages]
   (zipmap (map #(str/replace % #"\.md$" "") (keys pages))
           (map #(layout-base-header (md/to-html %)) (vals pages))))


 (defn html-pages [pages]
   (zipmap (map #(str/replace % #"\.html$" "") (keys pages))
           (map #(layout-base-header %) (vals pages))))


 (defn partial-pages [pages]
   (zipmap (keys pages)
           (map layout-base-header (vals pages))))

 (defn home-page [pages]
   (zipmap (keys pages)
           (map #(layout-base-header %) (vals pages))))

 (home-page (stasis/slurp-directory "resources/home" #".*\.(html|css|js)$"))


 (defn get-pages []
   (stasis/merge-page-sources
    {:landing (home-page (stasis/slurp-directory "resources/home" #".*\.(html|css|js)$"))
     :posts  (html-pages (stasis/slurp-directory "resources/posts" #".*\.html$"))
     :partials (partial-pages (stasis/slurp-directory "resources/partials" #".*\.html$"))
     :markdown (markdown-pages (stasis/slurp-directory "resources/md" #".*\.md$"))}))

 (def app (stasis/serve-pages get-pages))
 #+END_SRC

 and the website is working now!

*** My header and footer

 On my old Python-flask based static blog, I made a nav bar that I really liked. The source looks like this:

 #+BEGIN_SRC html

 <!DOCTYPE html>
 <html lang="en">
     <head>
        
         <meta charset="utf-8">
         <title>Nicholas George</title>    
         <meta name="viewport" content="width=device-width, initial-scale=1.0">
         <!--link to bootstrap css -->
         <link href="/static/css/bootstrap.min.css" rel="stylesheet">
         <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
     </head>
    
     <body style="font-size: 16px">

         <!--navbar -->
         <nav class="navbar navbar-inverse">
             <div class="container-fluid">
                 <div class="navbar-header">
                     <a class="navbar-brand" href="/"> Nick George</a>
                 </div>
                 <ul class="nav navbar-nav navbar-right">

                     <li class="inactive"><a href="/projects/">Projects</a></li>
                     <li class="inactive"><a href="/blog/">Posts</a></li>
                    <li class="inactive"><a href="/notes/">Notes</a></li> 
 <li>
   <a href="https://github.com/nkicg6">
     <span class="fa fa-github" style="font-size:24px"></span>
     
   </a>
 </li>
 <li>
   <a href="https://twitter.com/NicholasMG">
     <span class="fa fa-twitter-square" style="font-size:24px"></span>
     
   </a>
 </li>
                 </ul>                        

             </div>
         </nav>
         <div class="container">
 <!--content goes here-->            
    

 <!--footer -->
             <footer class="footer">
                 <div class="text-center">
                     <span class="text-muted">&copy 2017 Nicholas George</span>
                 </div>
             </footer>
         </div>
     <script data-cfasync="false" src="/cdn-cgi/scripts/f2bf09f8/cloudflare-static/email-decode.min.js"></script></body>
 </html>

 #+END_SRC

 I'll translate that to hiccup and add it to my base. This was relatively straightforward to translate to hiccup. I just had to figure out the nested list structure, but once you do it isn't so bad. 
 Here is my new =layout-base-header= function with the hiccup. 

 #+BEGIN_SRC clojure 
 (defn layout-base-header [page]
   (html5
    [:head
     [:meta {:charset "utf-8"}]
     [:meta {:name "viewport"
             :content "width=device-width, initial-scale=1.0"}]
     [:link {:rel "stylesheet" :href "https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" :integrity "sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" :crossorigin "anonymous"}]
     [:link {:rel "stylesheet" :href "https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css"}]
     [:script {:src "https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" :integrity "sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" :crossorigin "anonymous"}]]
    [:body
     [:nav {:class "navbar navbar-inverse"}
      [:div {:class "container-fluid"}
       [:div {:class "navbar-header"}
        (link-to  {:class "navbar-brand"} "/" "Nick George")]
       [:ul {:class "nav navbar-nav navbar-right"}
        [:li {:class "inactive"} (link-to "/" "Science")]
        [:li {:class "inactive"} (link-to "/" "Programming")]
        [:li {:class "inactive"} (link-to "/" "About")]
        [:li [:a {:href "https://github.com/nkicg6"}
              [:span {:class "fa fa-github" :style "font-size:24px"}]]]
        [:li [:a {:href "https://twitter.com/NicholasMG"}
              [:span {:class "fa fa-twitter-square" :style "font-size:24px"}]]]]]]
     [:div.logo "website-clj"]
     [:div.body page]
     [:footer {:class "footer"}
      [:div {:class "text-center"}
       [:span {:class "text-muted"} "&copy 2018 Nick George"]]]]))
 #+END_SRC

 I changed the section names and added dummy links for now, but the rest is a pretty straightforward translation. I am sure I am writing it in a non-compact way (i.e. it looks like classes under tags can be indicated as =.= attributes such as =[:div.logo "website-clj"]= expanding to 
 #+BEGIN_EXAMPLE
 <div class="logo"> "website-clj"</div>)
 #+END_EXAMPLE

 but this is working for me and it now renders like so:
 [[file:img/with-header-footer.png]]

 Next time, I will work on adding images to the simple webpage. 

* Part 2: Images and links 
:PROPERTIES:
:CUSTOM_ID: part2
:END:
/2018-08-07/
** Images and relative links
:PROPERTIES:
:CUSTOM_ID: images-and-links
:END:

*** Images
Adding images is important to any site, and links too for that matter. How well do they work in this format?
I'll start with a sample screenshot of my part of my landing page with an annotation. 
The first thing I did was make a new directory in my =resources/= directory called =public=, which will contain =img=, =css=, and =js= directories. The directory structure now looks like this:
#+BEGIN_EXAMPLE
resources/
├── home
├── md
├── partials
├── posts
└── public
    ├── css
    ├── img
    └── js
#+END_EXAMPLE

Now I will test it by adding a simple html tag for image to the source for my langing page. 

#+BEGIN_EXAMPLE
<h1>This is the landing page</h1>
<p>
 Welcome to it.

Here is a test image:

 <img src="../public/img/sample-img.png" alt="sample img!" />
</p>

#+END_EXAMPLE

This doesnt work. Changing the source to =<img src ="sample-img.png"/>= and copying the image to the same folder as the landing page doesn't help... 

**** Optimus  
     Christian Johansen's blog post uses =optimus= to wrap static folders. I'll start by trying to serve bootstrap locally rather than linking to the CDN. 
     I played around with this for a few hours yesterday and couldn't figure it out. I understood things reasonably well until =Optimus=, which doesn't make much sense to me because I do not have a background in web development so I really cant understand what it is doing or why it is doing it. This is likely because I did not spend much time with the docs, but they use a lot of web-jargon and I don't have the time or will to jump into that now. 

     Luckily, I explored Christian Johansen's website a little more and came across something that seemed quite useful ([[https://cjohansen.no/optimized-optimus-asset-paths-clojurescript/][here]]). But I didn't make much progress with this. 
...
Finally, after a few hours today I figured out how to add links. My directory structure now looks like so:
#+BEGIN_EXAMPLE
resources/
├── home
├── md
├── org-posts
├── partials
├── posts
└── public
    ├── css
    ├── img
    └── js

#+END_EXAMPLE
images can be added by referring to them relative to public. For example:
#+BEGIN_EXAMPLE
[:div.test [:img {:src "/img/test-img.png"}]] ; img test in the hiccup function layout-base-header
#+END_EXAMPLE

inserts the image stored in public/img/test-img.png

** org-workflow: Handling images
:PROPERTIES:
:CUSTOM_ID: org-mode-images
:END:

Back to my original org-export example file, I'll add an image in org-markup manner. 

#+BEGIN_EXAMPLE
#+OPTIONS: \n:1 toc:nil num:0 todo:nil ^:{}
#+HTML_CONTAINER: div



=* This is a test post
Here is a test post and a link to an image. 


[[file:~/personal_projects/website-clj/resources/public/img/test-img.png]]

#+END_EXAMPLE

Exporting this to html gives the following link structure in HTML:

#+BEGIN_EXAMPLE
<img src="img/test-img.png" alt="test-img.png" />
#+END_EXAMPLE

Which doesn't render properly wont work when I export the static site. Since all images are referred to =/img/=, I think I can easily write a string replace in Clojure and put it in my =html-posts= function to fix this formatting. 
/Note/
I know that I could use [[https://github.com/cgrand/enlive][enlive]] to do pretty much the same thing, but with how my current workflow is, I dont think it is even necessary. I will add that in if I need to, but for now I just dont seem to need it. 

#+BEGIN_SRC clojure 
;; main pages function. 
(defn html-pages [pages]
  (zipmap (map #(str/replace % #"\.html$" "") (keys pages))
          (map #(fn [req] (layout-base-header req %))
               (map #(str/replace % #"src=\"img" "src=\"/img") ;; this fixes links to images
                    (vals pages)))))
#+END_SRC


Now I can start up my server and check out the link formatting when I =view-source= on =http://localhost:3000/test_post=:


#+BEGIN_EXAMPLE
<img src="/img/test-img.png" alt="test-img.png" />
#+END_EXAMPLE

Perfect! I will factor out this function so it is more readable like so:

#+BEGIN_SRC clojure 
  (defn format-images [html]
    (str/replace html #"src=\"img" "src=\"/img"))

  ;; main pages function.
  (defn html-pages [pages]
    (zipmap (map #(str/replace % #"\.html$" "") (keys pages))
            (map #(fn [req] (layout-base-header req %))
                 (map format-images (vals pages)))))

#+END_SRC

I will likely need to add a similar helper when linking between pages in a post, but this =key value= handling of all the pages as simple html strings makes it very easy to add formatting fixes to my exported html pages. I am starting to feel the value and power of Clojure's emphasis on simplicity already--very cool!
* Part 3: Syntax highlighting and org-mode publishing
:PROPERTIES:
:CUSTOM_ID: part3
:END:
/2018-08-07/
** org-workflow: syntax highlighting
:PROPERTIES:
:CUSTOM_ID: syntax-highlighting-org
:END:

   [[https://cjohansen.no/building-static-sites-in-clojure-with-stasis/][Christian Johanson]] has an excellent description of formatting markdown fenced code blocks with pygments for nice display on his static site. His approach uses pygments and enliven and is very detailed and nice. However, the amazing =org-mode= takes care of syntax highlighting for me when I add =(setq org-src-fontify-natively t)= to my =config.org=. So here I will just test it real quick and see how it looks. 
In my HTML file, I will add a clojure code block like so:

#+BEGIN_EXAMPLE

#+OPTIONS: \n:1 toc:nil num:0 todo:nil ^:{}
#+HTML_CONTAINER: div




;* This is a test post
Here is a test post and a link to an image. 


[[file:~/personal_projects/website-clj/resources/public/img/test-img.png]]

And below is a test code block. 

#+BEGIN_SRC clojure 
(defn format-images [html]
  (str/replace html #"file:///Users/Nick/personal_projects/website-clj/resources/public" ""))

;; main pages function.
(defn html-pages [pages]
  (zipmap (map #(str/replace % #"\.html$" "") (keys pages))
          (map #(fn [req] (layout-base-header req %))
               (map format-images (vals pages)))))

#+END_SRC

How does it look?

#+END_EXAMPLE

This renders upon =M-x org-publish-project clj-site= to look like this:

[[file:img/syntax-highlighting.png]]

=org-src-fontify-natively= uses the currently active theme to highlight your source code. I just exported this using the [[https://github.com/fniessen/emacs-leuven-theme][Leuven theme]] (great for org-mode) and I like the way it looks. However, if I wanted to change it and use =enliven= with =pygments=, I would probably use some emacs-lisp code and packages such as those described here: https://emacs.stackexchange.com/questions/31439/how-to-get-colored-syntax-highlighting-of-code-blocks-in-asynchronous-org-mode-e , but for right now I dont think this is necessary for me so I will go with the raw html formatting from org-export. 

At this point, I removed all the markdown file stuff from my project as I don't plan to write in markdown and I cleaned up some other stuff I probably wont use. You can see the source code for my project [[https://github.com/nkicg6/website-clj][here]], all the code that does any work is in the =web.clj= file. 

*** Links
Will update when I need it. 
use (link-to)
** publishing
:PROPERTIES:
:CUSTOM_ID: publishing
:END:

*** Hosting on Github Pages

   From =lein=, Christian gives some nice instructions, so I followed those to see how the export looks and it seems to work nicely. Now, I'd like put my website on-line and I hosted my previous site on Github Pages, so I need a few config things to occur on export.  The first is the =CNAME= file, for mapping your domain name to the github repo. A good practice is to empty the target directory before exporting (as Christian did in =(stasis/empy-directory!)=), and I didn't see any options to exclude certain files, so I added a shell command to part of the export command and placed my =CNAME= in the =resources directory=:

#+BEGIN_SRC clojure 
  (ns website-clj.web
    (:require [optimus.assets :as assets]
              [optimus.export]
              [optimus.link :as link] 
              [optimus.optimizations :as optimizations]      
              [optimus.prime :as optimus]                    
              [optimus.strategies :refer [serve-live-assets]]
              [clojure.java.io :as io]
              [clojure.java.shell :as shell] ;; shell commands from clojure
              [clojure.string :as str]
              [hiccup.page :refer [html5]]
              [hiccup.element :refer (link-to image)]
              [stasis.core :as stasis]))
  ;; <-----snip----->

  ;; Christian's original:
  ;;
  ;; (def export-dir "build")
  ;; (defn export []
  ;;   (let [assets (optimizations/all (get-assets) {})]
  ;;     (stasis/empty-directory! export-dir)
  ;;     (optimus.export/save-assets assets export-dir)
  ;;     (stasis/export-pages (get-pages) export-dir {:optimus-assets assets})))
  ;;   
  ;; my edits to include the copy after export. 
  (defn cp-cname [export-dir]
    (shell/sh "cp" "resources/CNAME" (str export-dir "/CNAME")))


  (def export-dir "build")


  (defn export []
    (let [assets (optimizations/all (get-assets) {})]
      (stasis/empty-directory! export-dir)
      (optimus.export/save-assets assets export-dir)
      (stasis/export-pages (get-pages) export-dir {:optimus-assets assets}))
    (cp-cname export-dir)) ;; after export, copy CNAME back to base. 

#+END_SRC

Now I can keep CNAME where it is supposed to be the whole time. This seems hacky... but it also works without me messing up the awesome stasis code. 

To host on github pages, you also need the static files to be in a repo all by themselves. No problem, since =target= is already on my =.gitignore= from my Leiningen project, I can add my static content subdirectory (=nickgeorge.net=) and start a new repo in there. 
Unfortunately, with the previously mentioned problems with =(stasis/empty-directory!)=, my =.git= repo is deleted with every =lein build-site=. Looking in the [[https://github.com/magnars/stasis][Stasis code]], there doesn't seem to be a way to leave certain files in the target directory alone (There was with my Python Flask setup...) while this may be a good and relatively easy way to contribute to the library, for now I am going to do a very horribly inefficient thing and copy the =.git= directory to a safe space, then back after export. I'll have to do the same with the =.gitignore=

#+BEGIN_SRC clojure 
  (ns website-clj.web
    (:require [optimus.assets :as assets]
              [optimus.export]
              [optimus.link :as link] 
              [optimus.optimizations :as optimizations]      
              [optimus.prime :as optimus]                    
              [optimus.strategies :refer [serve-live-assets]]
              [clojure.java.io :as io]
              [clojure.java.shell :as shell] ;; shell commands from clojure
              [clojure.string :as str]
              [hiccup.page :refer [html5]]
              [hiccup.element :refer (link-to image)]
              [stasis.core :as stasis]))
  ;; <-----snip----->
  (def export-dir "target/nickgeorge.net")

  (def safe-dir "target")

  (defn cp-cname [export-dir]
    (shell/sh "cp" "resources/CNAME" (str export-dir "/CNAME")))

  (defn cp-gitignore [export-dir]
    (shell/sh "cp" "target/.gitignore" (str export-dir "/.gitignore")))

  (defn save-git [safe-dir export-dir] 
    (shell/sh "mv" (str export-dir "/.git") (str safe-dir "/.git")))

  (defn replace-git [safe-dir export-dir]
    (shell/sh "mv" (str safe-dir "/.git") (str export-dir "/.git")))


  (defn export []
    (save-git safe-dir export-dir) ;; copy .git to a safe place
    (let [assets (optimizations/all (get-assets) {})]
      (stasis/empty-directory! export-dir)
      (optimus.export/save-assets assets export-dir)
      (stasis/export-pages (get-pages) export-dir {:optimus-assets assets}))
    (cp-cname export-dir) ;; preserve CNAME
    (cp-gitignore export-dir) ;; Put .gitignore in
    (replace-git safe-dir export-dir)) ;; put .git back

#+END_SRC


*** one push publishing with Leiningen :alias
I can already build my website with my current alias, now I will make another to deploy!
The steps I need to do are: 
1. Command line build org-project
   - =org-publish-project clj-site= from the command line
   - remember to add a header to tell org to /not/ evaluate code like this: =#+PROPERTY: header-args :eval never-export=
   - This should be a clojure function called with =export= from =build-site= 
2. Then run build-site
3. =git add= and =git push= all changes.
   - This could also be a clojure function called with =export= from =build-site= 

The idea is that I just call build-site and it all happens automatically. I will adopt Christian's tests as well though. 
* Part 4: refactoring
:PROPERTIES:
:CUSTOM_ID: refactoring
:END:
/2018-08-09/
** Goals for today
:PROPERTIES:
:CUSTOM_ID: goals-today
:END:

1. Re-factor code for increased simplicity. Add a namespace to process pages. 
Goals for the future...
2. List subfolder pages on index page.
   - add edn metadata to fix names, links, etc.

** New namespace to process HTML
:PROPERTIES:
:CUSTOM_ID: new-ns
:END:

   In the spirit of the [[https://www.youtube.com/watch?v=f84n5oFoZBc][Hammock driven development]] I am going to re-think the code I am writing and make a plan for what exactly I want to do. First, of all, I want a way to process the text of pages independently without adding more little functions to this mess (mostly the =html-pages= function):

#+BEGIN_SRC clojure 
  (defn html-pages [base pages]
    (zipmap (map #(str base %) (map #(str/replace % #"(?<!index)\.html$" "") (keys pages)))
            (map #(fn [req] (layout-base-header req %))
                 (map format-images (vals pages)))))
  ;;---- snip ---

  (defn get-pages []
    (stasis/merge-page-sources
     {:landing (home-page (stasis/slurp-directory "resources/home" #".*\.(html|css|js)$"))
      :programming  (html-pages "/programming" (stasis/slurp-directory "resources/programming" #".*\.html$"))
      :science (html-pages "/science" (stasis/slurp-directory "resources/science" #".*\.html$"))
      :partials (partial-pages (stasis/slurp-directory "resources/partials" #".*\.html$"))
      :public (stasis/slurp-directory "resources/public" #".*\.(html|css|js)$")}))
  ;; --- snip ---

#+END_SRC

While =html-pages= isn't that bad now, all the maps and anonymous functions are getting a bit dense for me, and I plan to do some more pre-processing so I think it would really be best to re-factor it now. 
I also have no idea what =partials= are for in my map in =get-pages= (just copied from the tutorial), so that should probably go too. 

So, first thing first, how do I break this up, and what should I spin off into the new namespace called =process-pages=? 

To deal with the second part, I moved all the functions that deal directly with html formatting to the =process-pages= namespace, this follows the rule that each namespace should do one thing. I'll have the main =web.clj= handle building and exporting, mostly with the =get-pages= and =export= functions, but it makes sense that the html formatting should happen elsewhere (along the same lines, I have export helper functions that I broke out into a namespace called =export-helpers=). 
** New namespace
:PROPERTIES:
:CUSTOM_ID: declaring-ns
:END:

The declaration for this namespace looks like so:
#+BEGIN_SRC clojure 
  ;; website-clj/process_pages.clj
  (ns website-clj.process-pages
    (:require [clojure.string :as str]
              [hiccup.page :refer [html5]]
              [hiccup.element :refer (link-to image)]
              [stasis.core :as stasis])) ;; only for testing?

#+END_SRC

And the functions included here will be =html-pages=, =layout-base-header=, =format-images=, the other prepare pages functions =partial-pages=, and =home-page=. And any others I write. 
Now I just change =web.clj= to accept the new ns, and add the alias in front of any of the new functions

#+BEGIN_SRC clojure 
  ;;website-clj/web.clj
  (ns website-clj.web
    (:require [optimus.assets :as assets]
              [optimus.export]
              [optimus.link :as link] 
              [optimus.optimizations :as optimizations]      
              [optimus.prime :as optimus]                    
              [optimus.strategies :refer [serve-live-assets]]
              [clojure.java.io :as io]
              [clojure.string :as str]
              [stasis.core :as stasis]
              [website-clj.export-helpers :as helpers] ;; my export helper namespace
              [website-clj.process-pages :as process])) ;; process-pages namespace


#+END_SRC

** break up =html-pages=
:PROPERTIES:
:CUSTOM_ID: break-up-fns
:END:

Now for the first part, I'll look closely at =html-pages= and see what the different parts do

#+BEGIN_SRC clojure 
  ;; main pages formatting function
  (defn html-pages [base pages]
    (zipmap (map #(str base %) ;; 1
                 (map #(str/replace % #"(?<!index)\.html$" "") (keys pages))) ;; 2
            (map #(fn [req] (layout-base-header req %))
                 (map format-images (vals pages))) ;; 3 
            )) ;; 4

#+END_SRC

1. concatenates the "base url" onto the page name keys. This allows me to add things like "programming/" to the base of pages in the programming directory, and "science/" to the base of pages in the science directory. So the pages can be sub-sectioned into relevant topics.
2. removes .html from keys, which are the page names IF they don't start in index, which is for landing pages and /needs/ =.html=.
3. applies the header to the pages, and fixes image links.
4. returns a map of page names and values of raw html for pages. however this is a bunch of lazy functions

Really not too complicated. But to be more explicit, I'll make named functions to fix this.
To deal with =1= and =2=, I'll make a function to perform those roles.
The new function and its use in =html-pages= looks like so:

#+BEGIN_SRC clojure 
  (defn fmt-page-names [base name]
    (str base (str/replace name #"(?<!index)\.html$" ""))) ;; takes care of 1 and 2!

  ;; main pages formatting function
  (defn html-pages [base pages]
    (zipmap (map #(fmt-page-names base %) (keys pages)) ;; apply new fn
            (map #(fn [req] (layout-base-header req %)) 
                 (map format-images (vals pages))) 
            ))

#+END_SRC

Great. I am happy with that. I'll cross 1 and 2 off the list. Now the second part is beginning to format the html. Rather than doing all the formatting in one function, I'll have change my =format-images= function to =format-html= and then when I have any other html formatting to do to /all/ the pages I can add another function to =format-html=, which will just take raw html and mess with it. For now, it will only have the format-images function. 

#+BEGIN_SRC clojure 
  ;; format images
  (defn format-images [html]
    (str/replace html #"src=\"img" "src=\"/img"))

  (defn format-html [html]
    (-> html
        (format-images))
    ;; other fns for html here
    )

  ;; main pages formatting function
  (defn html-pages [base pages]
    (zipmap (map #(fmt-page-names base %) (keys pages)) 
            (map #(fn [req] (layout-base-header req %)) 
                 (map format-html (vals pages)))))

#+END_SRC

I am a lot happier with this. I have reduced complexity in my code by breaking up the anonymous functions, and explicitly naming them. I also don't have to deal with adding more complexity to my main =html-pages= function for future html formatting. I can just add more functions to the =format-html= function with the threading macro and be done with it. This will make editing and adding stuff much easier and more straightforward. I am trying to be more concise using the threading macros =->= and =->>=, which are explained really well [[https://cjohansen.no/clojure-to-die-for/][here]].

* Part 5: =edn= 
:PROPERTIES:
:CUSTOM_ID: part5
:END:
/2018-08-09/
- On the index page, automatically list all of the pages in whatever subfolder that index refers to.
  - Add [[https://github.com/edn-format/edn][edn]] metadata to the top of the every page, use this to assign a published date, title, and tags to the posts.
- Add tracking with google analytics or [[https://matomo.org/][Matomo]] (used by [[https://www.fsf.org/][FSF]])
- refactor code for increased simplicity
** All about =edn= metadata
:PROPERTIES:
:CUSTOM_ID: edn-metadata
:END:

1. create names of pages based on =edn= metadata as opposed to just using the file names. 
2. make a list of page with links to them in reverse chronological order (dates from =edn= metadata) in the appropriate index home page (i.e. a list of programming pages in the programming folder (except index itself...) to list in the programming index page, same for science...)
   - This will likely be done using enlive to add links to a special div tag placed in the index page body.
3. strip =edn= from the raw html. 
This will be done by a function that acts on the map returned by =html-pages=. I think that is the simplest way to do it. 
*** Read =edn= metadata

    So in order to use metadata to name, tag, and add dates to pages I'll use a combination of [[https://github.com/cgrand/enlive][enlive]] and Clojure's [[https://clojuredocs.org/clojure.edn][edn]] data format. I'll insert the =edn= tags at the top of the org mode page (in html tags so it exports) and then parse it using =enlive= and use this to rename and do all the other fancy stuff with the data. To work on this, I'll add some =edn= metadata to a test html page and start playing. First I need to add =enlive= to my =project.clj=
#+BEGIN_SRC clojure 
  ;; project.clj
  (defproject website-clj "0.1.0-SNAPSHOT"
    :description "Personal website built with Clojure, Stasis, and Hiccup"
    :url "http://nickgeorge.net"
    :license {:name "Eclipse Public License"
              :url "http://www.eclipse.org/legal/epl-v10.html"}
    :dependencies [[org.clojure/clojure "1.8.0"]
                   [stasis "1.0.0"]
                   [ring "1.2.1"]
                   [hiccup "1.0.5"]
                   [me.raynes/cegdown "0.1.1"]
                   [optimus "0.14.2"]
                   [enlive "1.1.6"]]
    :ring {:handler website-clj.web/app}
    :profiles {:dev {:plugins [[lein-ring "0.8.10"]]}}
    :aliases {"build-site" ["run" "-m" "website-clj.web/export"]})

#+END_SRC

and then run =lein deps= at the command line. I'll go through this [[https://github.com/swannodette/enlive-tutorial][enlive tutorial]] to figure out how to parse that portion of the page. My =test.org= doc looks like this:

#+BEGIN_EXAMPLE
=#+HTML: <div class="edn">=
=#+HTML: {:title "renamed" :date 2018-08-05 :tags (clojure testing post)}=
=#+HTML: </div>=
=#+OPTIONS: \n:1 toc:nil num:0 todo:nil ^:{}=

=* Here is my test content=

and some code 

=#+BEGIN_SRC clojure=
(test clj-code)
(def test-me "test string")
=#+END_SRC=

#+END_EXAMPLE

As you can see in the header I added the =#+HTML= tags, which will export literally when I run =org-publish-project clj-site= I get this:

#+BEGIN_EXAMPLE
<div class="edn">
{:title "renamed" :date 2018-08-05 :tags (clojure testing post)}
</div>

<div id="outline-container-orgd13af6f" class="outline-2">
<h2 id="orgd13af6f">Here is my test content</h2>
<div class="outline-text-2" id="text-orgd13af6f">
<p>
and some code<br />
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #707183;">(</span><span style="color: #006FE0;">test</span> clj-code<span style="color: #707183;">)</span>
<span style="color: #707183;">(</span><span style="color: #0000FF;">def</span> <span style="color: #BA36A5;">test-me</span> <span style="color: #036A07;">"test string"</span><span style="color: #707183;">)</span>
</pre>
</div>
</div>
</div>

#+END_EXAMPLE

With the useful stuff at the top in the tag. I made a new test folder for this, and I moved the test.html there. So now, I'll read that in and start messing around. 

I am playing with this code at the bottom of my new =process-clj= namespace. 
#+BEGIN_SRC clojure 
  ;; get the test of your first page
  (def test-pages ((first (vals (html-pages "/test"
                                            (stasis/slurp-directory "resources/test" #".*\.html$")))) "" ))
  test-pages ;; => html for the page
#+END_SRC

The =first vals= from my =html-pages= function returns a function, and I just call it with an empty string to give me the html text and store it in =test-pages=. Now I am going to use =enlive= to scrape it and read the stuff under the =edn= class div to start manipulating my keys and links. 
This took some time, but eventually I figured out this code:

#+BEGIN_SRC clojure 
  (ns website-clj.process-pages
    (:require [clojure.string :as str]
              [hiccup.page :refer [html5]]
              [hiccup.element :refer (link-to image)]
              [net.cgrand.enlive-html :as enlive] ;; add enlive!
              [stasis.core :as stasis] ;; only for testing?
              ))

  ;; --- snip ---

  (def test-pages (enlive/html-snippet ((first (vals (html-pages "/test"
                                                                 (stasis/slurp-directory "resources/test" #".*\.html$")))) "" )))

  (def selected (enlive/select test-pages [:#edn enlive/text-node]))
  selected
  ;; => "\n{:title \"renamed\" :date 2018-08-05 :tags (clojure testing post)}\n"
#+END_SRC

Now I'll just read that in as a map using the clojure =edn= library. 

#+BEGIN_SRC clojure 
  (ns website-clj.process-pages
    (:require [clojure.string :as str]
              [hiccup.page :refer [html5]]
              [hiccup.element :refer (link-to image)]
              [net.cgrand.enlive-html :as enlive]
              [clojure.edn :as edn] ;; require edn 
              [stasis.core :as stasis] ;; only for testing?
              ))

  ;; --- snip ---
  ;; get the test of your first page
  (def test-pages (enlive/html-snippet ((first (vals (html-pages "/test"
                                                                 (stasis/slurp-directory "resources/test" #".*\.html$")))) "" )))

  (def selected (enlive/select test-pages [:#edn enlive/text-node]))
  (edn/read-string (apply str selected))
  ;; => {:title "renamed" :date "2018-08-05" :tags ("clojure" "testing" "post")}
#+END_SRC

I refactored that into a function using the threading macro like so:
#+BEGIN_SRC clojure 
  (def test-html ((first (vals (html-pages "/test"
                                           (stasis/slurp-directory "resources/test" #".*\.html$")))) "" ))
  (defn parse-edn
    [html]
    (-> html
        (enlive/html-snippet)
        (enlive/select [:#edn enlive/text-node])
        (->> (apply str)) ;; I know this is bad form, but it is the best way I know how to do it..
        (edn/read-string)))

  (parse-edn test-html)
  ;; => {:title "renamed" :date "2018-08-05" :tags ("clojure" "testing" "post")}
#+END_SRC

Unfortunately, I need to use =(apply str html)=, with the html passed as the last argument. The =->= macro inserts the result of the previous form as the /first/ argument, which would result in the apply step looking like =(apply html str)= which will not work. The =->>= macro inserts the result of the previous form as the /last/ argument, so added that macro to apply to only the =apply str= step. I've read mixing these macros is bad form, but for now it seems to work so I'll leave it be. 

I created another =test.html= page called =test2.html=, and I just tested to make sure I could map over it with =parse-edn=. You'll notice I had to use =prepare-pages= in order to force the functions to evaluate. 

#+BEGIN_SRC clojure 
  (defn prepare-page [page]
    (if (string? page) page (page "")))

  (map parse-edn
       (map prepare-page
            (vals
             (html-pages "/test"
                         (stasis/slurp-directory "resources/test" #".*\.html$")))))

  ;;=>  [{:title "renamed" :date "2018-08-05" :tags ("clojure" "testing" "post")} {:title "renamed2" :date "2018-08-06" :tags ("clojure" "testing2" "post")}]

#+END_SRC

Now I made a few changes to =parse-edn= to get my link generator working quickly. Here is that updated function:

#+BEGIN_SRC clojure 
  ;; --- snip ---
  (defn prepare-page [page]
    (if (string? page) page (page "")))

  (defn parse-edn
    [html]
    (-> html
        (prepare-page) ;; new, render the page if a fn
        (enlive/html-snippet)
        (enlive/select [:#edn enlive/text-node])
        (->> (apply str)) ;; I know this is bad form, but it is the best way I know how to do it..
        (edn/read-string)
        (get :title))) ;; new just return the title for now. 
#+END_SRC

I just added =prepare-page= in order to force render the functions, and the =(get :title)= to return just the title for now. However in my main =get-pages= function in =web.clj=, the index pages will be included. Since it would be silly to link to those in the link pages, I will filter those out with a regex. The final form to give me a =hash-map= of ={url-title metadata-title}= looks like this:

#+BEGIN_SRC clojure 

  (defn remove-index [values] (remove #(re-matches #"(/.*/)?index(.html)?" %) values))

  (def link-map
    (zipmap (remove-index (keys test-map))
            (remove-index (map parse-edn (vals test-map)))))

#+END_SRC

I envision using this in a separate series of functions to create lists of urls for all my pages. Basically, this would be reduced to a single list of href links, which I would pass to a helper function out side of =get-pages=, which would then insert the list using enlive to the index pages /only/ by using a unique div element. A skeleton looks like so:

#+BEGIN_SRC clojure 
  ;; web.clj 

  ;; define links below
  (def list-of-science-links (process/make-links science-map))
  (def list-of-programming-links (process/make-links programming-map))

  ;; below, process/insert-links will add the links to index.html using enlive and a unique selector

  (defn get-pages []
    (stasis/merge-page-sources
     {:landing  (process/home-page (stasis/slurp-directory "resources/home" #".*\.(html|css|js)$"))
      :programming  (process/insert-links list-of-programming-links (process/html-pages "/programming" (stasis/slurp-directory "resources/programming" #".*\.html$"))) ;; NEW!
      :science (process/insert-links list-of-science-links (process/html-pages "/science" (stasis/slurp-directory "resources/science" #".*\.html$"))) ;; NEW
      :partials (process/partial-pages (stasis/slurp-directory "resources/partials" #".*\.html$"))
      :public (stasis/slurp-directory "resources/public" #".*\.(html|css|js)$")}))

#+END_SRC

** making links from page lists
:PROPERTIES:
:CUSTOM_ID: page-lists
:END:

So todo, I need to write a function to make a valid html link, then figure out how to add it to the index page. 

I'll start tackling these by first addressing the =process/make-links= problem.  First, I'll make =link-map=, defined in the previous section into a into a function

#+BEGIN_SRC clojure 
  ;; make a map for urls
  (defn link-map [stasis-map]
    (zipmap (remove-index (keys stasis-map))
            (remove-index (map parse-edn (vals stasis-map)))))

#+END_SRC

Now generating links from these is shown with the following hiccup code (note I had to update my =ns=):

#+BEGIN_SRC clojure 
  (ns website-clj.process-pages
    (:require [clojure.string :as str]
              [hiccup.core :refer [html]] ;; just added
              [hiccup.page :refer [html5]]
              [hiccup.element :refer (link-to image)]
              [net.cgrand.enlive-html :as enlive]
              [clojure.edn :as edn] 
              [stasis.core :as stasis] ;; only for testing?
              ))


  ;; --- snip ---


  (def test-map (html-pages "/test"
                            (stasis/slurp-directory "resources/test" #".*\.html$"))) ;; I'll work with the map that stasis returns

  ;; make a map for urls
  (defn link-map [stasis-map]
    (zipmap (remove-index (keys stasis-map))
            (remove-index (map parse-edn (vals stasis-map))))) ;; removes index files form the maps. 

  ;; this makes a list of links with Hiccup. enlive will then insert it.
  (defn link-list [links]
    (html [:ul (for [[k v] links]
                 [:li (link-to k v)])])) ;; returns the html for the list of links. 

  (link-list (link-map test-map)) ;; demo how it will run.

  ;; => "<ul><li><a href=\"/test/test\">renamed</a></li><li><a href=\"/test/test2\">renamed2</a></li></ul>"
#+END_SRC

Great! Quick refactoring for simplicity:

#+BEGIN_SRC clojure 
  (defn make-links [stasis-map]
    (-> stasis-map
        (link-map)
        (link-list)))


  (make-links test-map)

  ;;=> "<ul><li><a href=\"/test/test\">renamed</a></li><li><a href=\"/test/test2\">renamed2</a></li></ul>"
#+END_SRC

Now I need to insert a new special =<div>= tag into my index html, then use enlive to insert these links!

** Inserting =hiccup= html with =enlive=
:PROPERTIES:
:CUSTOM_ID: making-links
:END:

First, I wanted to make sure that I could hide the metadata from the normal page. I /could/ use enlive to actually delete them, but that is really just unnecessary. I don't care if it is in the html, I'd just rather not show it. So I made a css file called =hide.css= and had it hide all the =id=edn= divs.

#+BEGIN_SRC css
  #edn {
      display: none;
  }
#+END_SRC

Easy. Now I will use the =include-css= hiccup header and add the following to my =hiccup=-defined header:

#+BEGIN_SRC clojure 
  ;; process-pages ns
  (ns website-clj.process-pages
    (:require [clojure.string :as str]
              [hiccup.core :refer [html]]
              [hiccup.page :use [html5 include-css include-js]] ;; include hiccup helpers
              [hiccup.element :refer (link-to image)]
              [net.cgrand.enlive-html :as enlive]
              [clojure.edn :as edn] 
              [stasis.core :as stasis] ;; only for testing?
              ))

  ;; --- snip ---
  (defn layout-base-header [request page]
    (html5
     [:head
      [:meta {:charset "utf-8"}]
      ;;... --- snip ---
      (include-css "/css/hide.css") ;; the new stuff
      ;;... --- snip ---
      ]
     ;;Much more here, I cut it out for simplicity
     ))

#+END_SRC

Great, I can access all the elements of that like a normal hash-map now.
The element I want to insert the links into is called 
#+BEGIN_EXAMPLE
<div id="pageListDiv">Page nav list Here</div> 
#+END_EXAMPLE

Which will /only/ exist in the index.html pages that should have this list. 


*** adding links

After a lot of troubleshooting, I finally came up with this. 

#+BEGIN_SRC clojure 
  (defn add-links [page links]
    (-> page
        (prepare-page) ;; forse eval of lazy pages
        (enlive/sniptest
         [:#pageListDiv] ;; exists only in index pages. 
         (enlive/content links))))

#+END_SRC

This can be mapped over the values like so:

#+BEGIN_SRC clojure 
  ;; used for testing
  (def stasis-map (html-pages "/test" (stasis/slurp-directory "resources/test" #".*\.(html|css|js)$")))
  (def test-html ((first (vals stasis-map)) ""))
  (def test-links (make-links (stasis/slurp-directory "resources/test" #".*\.(html|css|js)$")))

  ;; map it!

  (map #(add-links % test-links)
       (vals stasis-map))

#+END_SRC

This seems to give the exact output I was looking for. Now when I refer to how it will actually be used:

#+BEGIN_SRC clojure 
  ;; web.clj

  ;; --- snip ---

  (defn get-pages []
    (stasis/merge-page-sources
     {:landing (process/home-page (stasis/slurp-directory "resources/home" #".*\.(html|css|js)$"))
      :programming  (process/html-pages "/programming" (stasis/slurp-directory "resources/programming" #".*\.html$"))
      :science (process/html-pages "/science" (stasis/slurp-directory "resources/science" #".*\.html$"))
      :partials (process/partial-pages (stasis/slurp-directory "resources/partials" #".*\.html$"))
      :public (stasis/slurp-directory "resources/public" #".*\.(html|css|js)$")

      ;; see below!

      :test (zipmap (keys (process/html-pages "/test" (stasis/slurp-directory "resources/test" #".*\.(html|css|js)$")))
                    (map #(process/add-links % test-links) (vals (process/html-pages "/test" (stasis/slurp-directory "resources/test" #".*\.(html|css|js)$")))))}))


#+END_SRC

I still need to return a zipmap like =html-pages= does, but I also need to use enlive to insert the links. 
This technically does what I want, unfortunately all my =>= characters are escaped as =&gt=, so the html is not rendering as a list. To fix that, I set up a quick helper function to un-escape those characters and added it like so:

#+BEGIN_SRC clojure 
  (defn add-links [page links]
    (-> page
        (prepare-page) ;; forse eval of lazy pages
        (enlive/sniptest
         [:#pageListDiv] ;; exists only in index pages. 
         (enlive/content links))
        (str/replace #"&gt;" ">") ;; replace greater than
        (str/replace #"&lt;" "<"))) ;; replace less than
#+END_SRC

This works well for my purposes. I need to refactor and work with this a lot, because right now it is not very resilient. For example, if the =edn= is misformed, or if none of the pages even have the metadata then it will fail with a Java null pointer exception, but for now this will definitely work.
* References
:PROPERTIES:
:CUSTOM_ID: references
:END:

- [[https://github.com/magnars/stasis][Stasis]]
- [[https://github.com/magnars/optimus][Optimus links]]
- [[https://github.com/ring-clojure/ring/wiki/Static-Resources][Ring static middleware]]
- [[https://github.com/yokolet/hiccup-samples][hiccup samples]]
- Christian Johansen's post on Building static sites in Clojure with Stasis https://cjohansen.no/building-static-sites-in-clojure-with-stasis/
  - handling links https://cjohansen.no/optimized-optimus-asset-paths-clojurescript/
  - Also his post here is similar with some (useful) differences https://github.com/cjohansen/cjohansen-no/blob/master/resources/md/building-static-sites-in-clojure-with-stasis.md
- [[https://8thlight.com/blog/colin-jones/2010/12/05/clojure-libs-and-namespaces-require-use-import-and-ns.html][Clojure namespaces]]
- add more org-mode links!

/Published: {{{date}}}/
/last updated: {{{time(%Y-%m-%d %a)}}}/
